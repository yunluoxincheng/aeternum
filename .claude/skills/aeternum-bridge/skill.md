# Aeternum Bridge Management

Aeternum UniFFI 桥接层管理技能

## User-invocable skill

Use this skill when managing the Rust ↔ Kotlin UniFFI bridge layer in the Aeternum project.

## Trigger words

- UDL, interface definition, UniFFI, proc-macro
- Bridge code, FFI interface, Kotlin generation
- Add interface method, modify bridge
- Rust-Kotlin bridge, cross-language binding
- Windows compatibility, UDL parsing error

## Context

The Aeternum project uses UniFFI **proc-macro mode** to bridge Rust cryptographic core with Kotlin Android layer.

**Core principles:**

**Handle-based access:**
- Kotlin must NOT hold plaintext key `ByteArray`
- All decryption operations in Rust
- Return sanitized data or handles only

**Two-phase commit:**
- Rust generates data stream
- Kotlin executes atomic rename

**Proc-macro mode (recommended):**
- ✅ Cross-platform compatible (Windows/Linux/macOS)
- ✅ Type-safe (compile-time checking)
- ✅ No UDL file maintenance
- ✅ Rust-idiomatic

## Bridge code location

- **Generated Kotlin**: `android/app/src/main/kotlin/aeternum/uniffi/aeternum/` (auto-generated, do not edit)
- **Rust bridge module**: `core/src/bridge/`

## Proc-macro workflow

### 1. Add UniFFI exports in Rust

Use `#[uniffi::export]` and `#[derive(uniffi::*)]` macros directly in Rust:

```rust
// Error type
#[derive(Debug, Clone, PartialEq, Eq, uniffi::Error)]
pub enum PqrrError {
    EpochRegression { current: u32, attempted: u32 },
    HeaderIncomplete { device_id: String, reason: String },
    // ...
}

// Enum
#[derive(Debug, Clone, PartialEq, Eq, uniffi::Enum)]
pub enum ProtocolState {
    Idle,
    Rekeying,
    RecoveryInitiated,
}

// Record (data class)
#[derive(uniffi::Record, Debug, Clone)]
pub struct DeviceInfo {
    pub device_id: Vec<u8>,
    pub device_name: String,
    pub epoch: u32,
}

// Object (interface)
#[derive(uniffi::Object)]
pub struct VaultSession {
    vault_key: Zeroizing<Vec<u8>>,
}

#[uniffi::export]
impl VaultSession {
    #[uniffi::constructor]
    pub fn new(vault_key: Vec<u8>) -> Self {
        Self { vault_key: Zeroizing::new(vault_key) }
    }

    pub fn decrypt_field(&self, record_id: String, field_key: String) -> Result<String, PqrrError> {
        // INVARIANT: Return sanitized data only
        Ok("...".to_string())
    }
}
```

### 2. Configure scaffolding

In `core/src/lib.rs`:

```rust
uniffi::setup_scaffolding!("aeternum");
```

### 3. Generate bridge code

Run `./scripts/generate-bridge.sh` (proc-macro mode is default):

```bash
# Default: proc-macro mode (Windows compatible)
./scripts/generate-bridge.sh

# Or specify platform
./scripts/generate-bridge.sh --platform android

# Legacy UDL mode (not recommended for Windows)
./scripts/generate-bridge.sh --mode udl
```

### 4. Use in Kotlin

```kotlin
// Generated by UniFFI in android/app/src/main/kotlin/aeternum/uniffi/aeternum/
import uniffi.aeternum.VaultSession
import uniffi.aeternum.AeternumEngine

// In your app code
val engine = AeternumEngine.newWithPath("/path/to/vault")
val session = engine.unlock(hardwareKeyBlob)
val password = session.decryptField("rec_001", "password")
session.lock()
```

## Type mapping (Rust → Kotlin)

| Rust | Kotlin |
|------|--------|
| `String` | `String` |
| `Vec<u8>` | `ByteArray` (pass as `toByteArray()`) |
| `i32/u32` | `Int` |
| `i64/u64` | `Long` |
| `bool` | `Boolean` |
| `Option<T>` | `T?` |
| `Result<T, E>` | `T` (throws exception) |

## Dependencies

### Cargo.toml

```toml
[dependencies]
uniffi = "0.31"

[build-dependencies]
uniffi = { version = "0.31", features = ["build"] }
```

### build.gradle.kts

```kotlin
dependencies {
    implementation("org.mozilla.uniffi:uniffi-bindgen:0.31.0")
    implementation("org.mozilla.uniffi:uniffi-kotlin:0.31.0")
}
```

## Important notes

- ✅ **Use proc-macro mode** for Windows compatibility
- ❌ **Do NOT edit** generated Kotlin files
- ❌ **Do NOT commit** generated files to git (in .gitignore)
- ✅ **Regenerate** after any bridge code changes

## Related documentation

- [UniFFI 桥接契约](../../docs/bridge/UniFFI-Bridge-Contract.md)
- [UniFFI Proc-Macro 迁移指南](../../docs/bridge/UniFFI-Proc-Macro-Migration.md)

## After code generation

Ask the user:
1. Build Rust core for Android? (run `./scripts/build-core.sh`)
2. Verify Kotlin code synced in Android Studio
